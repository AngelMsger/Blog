---
title: 什么是MongoDB复制集
date: 2018-01-04 21:15:24
tags:
- Redis
- HA
- Replication
- Database
- DevOps
categories:
- Database
thumbnail: "/images/什么是MongoDB复制集.jpg"
---
高可用MongoDB集群入门篇。

# 为什么不是单节点
以前写程序每天增删改查，也没见过什么MySQL搞不定的事。后来NoSQL流行起来了，说是宽松的约束使它灵活性更大并发能力更强。不过MongoDB这东西吸引我的倒不是这个，毕竟我写的程序结构并不复杂，并发量大多数时候也都是1，偶尔能上升到2→\_→。MongoDB基于文档的存储，给了开发者更大的自由，平时写个程序也不太需要先费时费力设计表了，OOP中的对象直接转换到JSON就可以存取。而且MongoDB提供的全文索引和Geo地理位置索引拿来搞点花样也比较容易。
如果某一时刻并发量达到服务器能承受的上限，MongoDB实例可能会因为各种各样的原因不能继续服务。如果机器上只有一个MongoDB实例，恐怕用户就无法再继续看到正常的页面了。

# 复制集简述
在MongoDB复制集中，存在一个主节点，若干从节点，从节点拥有投票权，此外可能还存在专职的选举节点。主节点可读可写，写入请求发送至主节点后，数据会同步到从节点上。从节点提供了数据冗余，也可以配置从节点为可读，分担一部分主节点的压力，这通常可用在那些对数据实时性不是很高的场景下。如果某一时间主节点挂了，从节点会重新选举主节点继续服务。当主节点从灾难中恢复时，会重新加入选举。

# 复制集特性
1. 与MySQL主从结构不同，MongoDB从节点绝对不可写，降低了数据不一致的可能性 (MySQL中root及拥有super权限的用户可写入从节点)。
2. 大多数原则：当集群中能够正常服务的节点降低至低于总数的一半时，将停止选举，现存主节点也会降为从节点，此时整个集群将不可写。

# 建立一个简单的MongoDB集群
运行多个MongoDB实例，并指定相同的replSet值：
{% codeblock "运行多个MongoDB实例，并指定相同的replSet值" %}
mongod --replSet=Foo
{% endcodeblock %}
在MongoShell中创建配置对象：
{% codeblock "在MongoShell中创建配置对象" %}
config = {_id: 1, members: [{_id: 1, host: "1.2.3.4:27017"}, {_id: 2, host: "1.2.3.5:27017"}]}
{% endcodeblock %}
应用配置对象：
{% codeblock "应用配置对象" %}
rs.config(config)
{% endcodeblock %}

# rs包含的关于复制集的方法
- rs.config(配置对象)：应用一个配置，用于初始化
- rs.reconfig(配置对象)：重新应用一个配置，用于修改和更新配置，会造成瞬间的断开连接，慎用
- rs.status()：查看复制集状态，面向管理人员，即使隐藏节点在此也是可见的。
- rs.isMaster()：返回的是应用得到的集群信息，即隐藏节点在此是不可见的。
- rs.slaveOk(1或0)：从节点是否可读
- rs.stepDown()：将当前节点降级为从节点

# 一些额外的参数
你可以为config.members添加更多属性来描述一个节点。
- arbiterOnly：这是一个专职的投票节点。
- priority：优先级，若为0，则不可被选举为主节点。优先级越高，越会被优先选为主节点，可以为硬件更优秀的节点配置高优先级。
- hidden：若为真，则为隐藏节点，对于应用程序不可见。
- slaveDelay：若存在且大于0，则此节点为延时节点，单位为秒。延时节点将会在主节点数据更新之后，经过延迟时间之后才进行同步，主要为主节点发生灾难性事件时提供挽救的可能性。延时节点必须为不可成为主节点的隐藏节点。
