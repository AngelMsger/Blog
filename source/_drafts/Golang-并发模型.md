---
title: Golang 并发模型
tags:
---

在理解 Golang 的并发模型前, 先简单回顾一下操作系统对线程的调度.

## 操作系统的调度策略

操作系统对线程的调度通常是复杂的, 为了尽可能保证程序运行的高效, 它需要考虑多种因素, 如 CPU 物理核心数量, CPU 缓存和 NUMA 等.

程序的本质是一段需要顺序执行的机器指令, 在操作系统的这个概念抽象为线程. 每个程序运行后会创建一个进程, 而进程包含一个初始线程, 初始线程在必要时可以创建更多线程, 彼此独立运行. 线程是操作系统调度并发的最小单位. 多个线程可以并发(Concurrent)执行, 此时多个线程在一个物理核心上交替执行, 或者并行(Parallel)执行, 此时多个线程在不同的物理核心上同时执行. 每个线程维护自身执行机器指令所需的必要状态.

操作系统的调度器会调度线程执行, 以保证只要有线程处于可运行(Runable)状态时, CPU 的物理核心就不会闲置(Idle). 所有可运行的线程在物理核心上并发或并行执行, 以使我们从应用层的角度看起来这些线程都在同时执行. 我们在操作系统课程上了解过一些操作系统对线程的调度策略, 包括如何按优先级调度, 如何避免低优先级的进程长期处于饥饿状态和如何尽可能降低各个线程执行的延迟等, 算法虽然复杂, 但好在这已经是一个历史悠久的问题, 所以目前的解决方案也比较成熟.

## 

操作系统线程有三种状态:

* Waiting: 线程暂停执行并等待特定事件, 比如磁盘或网络数据, 系统调用返回和同步条件(锁)等.
* Runnable: 线程已经准备就绪并等待被调度到物理核心上执行指令. 如果大量线程处于这种状态, 那么单个线程需要等待较长的时间就会变长, 周期内能拿到的执行时间就变短, 继而产生负面的性能影响.
* Executing: 线程正在物理核心上执行指令.

工作负载有两种类型:

* CPU 密集型: 程序多数时间在进行计算, 如矩阵乘法. 这种工作负载下线程几乎不会进入 Waiting 状态.
* IO 密集型: 程序多数时间在进行网络访问和操作系统调用等, 如爬取网页. 这种工作负载下线程常常需要进入 Waiting 状态.

上下文切换

Linux, MacOS 和 Windows 的线程调度都是抢占式的(preemptive scheduler), 这意味着:

* 下一个可执行的线程是不可预测的. 线程优先级, 事件回调等因素都在时刻影响着可能的调度结果.
* 应用程序不能假设操作系统的调度结果.

暂停一个处于 Executing 状态的线程, 然后从处于 Runable 状态的线程队列中选一个进入 Executing 状态的过程称为上下文切换(Context Swithing). 这种暂停既可能是主动的, 如线程等待一个网络事件, 此时线程会进入 Waiting 状态, 也可能是被动的, 比如耗尽了时间片, 此时线程会进入 Runnable 状态.
