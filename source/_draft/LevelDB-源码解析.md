---
title: LevelDB 源码解析
date: 2020-03-19 13:47:35
tags:
---

# 概述

leveldb真是一个非常棒的项目! 曾经别人和我谈代码质量, 我总是喜欢以Android源码举例表达心中的理想风格, 这次读完leveldb之后对Google的设计能力更加心向往之, 遑论这可是用C++写出来的.

# 速览

## 头文件

头文件位于源码目录下的include/leveldb中, 是leveldb对外暴露的公共接口, leveldb保证接口的稳定性但可能会不断调整接口背后的实现. 因此我们基于leveldb开发时也只应该依赖这些接口.

### db.h

该文件包含了DB实例相关的主要接口, 是源码阅读比较好的入口.

#### Snapshot类

这其实是快照的抽象类, 只包含一个虚析构方法. 快照在leveldb中是数据库在某个时间点的状态, 其实例化后的对象不可修改, 因此是线程安全的.

#### Range结构体

`Range`结构体表示键的范围, 其包含两个`Slice`实例: `start`和`limit`, 分别表示范围的起始和终止的键, 左闭右开, ` Slice`类会在后面介绍, 这里可以理解为byte数组.

#### DB类

`DB`类表示一个持久化的键值映射, 其键内部有序, 并且实例方法线程安全. 此处的`DB`类同样是一个抽象类, 其实现为`DBImpl`, 此处我们先观察其接口, 后续在`DBImpl`相关章节再讨论具体实现.

该类包含一个静态方法`Open`, 可以接受一些配置参数, 随后根据配置参数打开一个实例. 参数中的`name`为数据库的名称, leveldb会根据名称找到相应数据存放的目录. 打开的实例为堆上对象, 因此需要手动销毁. 可以看到源码中显式将拷贝构造函数及赋值操作符重载标记为`= delete`, 因此该类的实例不能被直接传递. 同样的, 该类包含一个虚析构函数.

接下来则是CRUD相关接口. 这些函数均为纯虚函数, 这里只有函数签名. 读函数接受`ReadOptions`实例, 写函数接受`WriteOptions`实例, 并统一返回`Status`对象. 我们按序展开源码, 因此这些类的定义也稍后再展开介绍. leveldb中的键和值均为`Slice`实例. 留意其遍历方法的签名, 即`NewIterator`方法, 如果你熟悉`STL`中的那个让人"卧槽, 牛逼"的迭代器设计模式, 那这个在想法上是异曲同工的.

接下来是获取和释放快照的两个函数, 同样是纯虚函数, 也在后续`DBImpl`相关章节再讨论.

接下来是两个指标方法, `GetPropertiy`和`GetApproximateSizes`, 前者返回具体实现类提供的一些属性, 后者返回指定范围键值所占空间, 由于不包含最近写入造成的影响, 因此是近似结果.

最后是一个优化方法`CompactRange`, 接受两个参数`start`和`end`, 左闭右开, 收缩指定范围内的键值控件.  注意是收缩(Compact)不是压缩(Compress), 这一操作只是把由于覆盖或标记删除而失效的键值彻底清理并重新排列以减小遍历成本.

#### DestroyDB函数

销毁指定名称的数据库文件, 另外有后向兼容的问题在返回值上有一些特殊处理, 具体见文档.

#### RepairDB函数

如果`DB`实例打开失败, 比如因为加载过程中发现checksum通不过, 则可以调用此方法尽可能多的恢复一些数据.

### options.h

#### CompressionType枚举

leveldb将数据组织为若干个Block, 每个Block持有一定范围的键值. 每个Block在写回磁盘前可以执行压缩, 该枚举指出了压缩的方式. 可以看到其内建支持的压缩方法为[Snappy](https://github.com/google/snappy). 该算法也是Google开源, 以速度为主要目标, 其实现相较[Zlib](https://www.zlib.net/)的fastest级别更快, 但压缩率也更低, 在Intel Core2 2.4Ghz的硬件下, 压缩速度可达每秒约200~500MB, 解压速度则可达每秒约400~800MB, 这一速度已经大于了大多数磁盘的I/O速度, 因此启用该压缩算法的代价较低. 包括[MongoDB](https://www.mongodb.com/)默认存储引擎[WiredTiger](http://www.wiredtiger.com/)在内的一些数据库产品也使用该压缩算法.

#### Options结构体

该结构体主要用处是作为`DB::Open`的参数用以控制数据库的行为, 其中很多参数顾名思义, 就不详细说了, 但另一些涉及后续对DB行为的理解, 这里简单展开:

- `comparator`, 这是一个`Comparator`类的实例, `DB`内的键值对是有序的, 此参数定义了键间的比较方式, 默认为`BitewiseComparatorImpl`, 即默认情况下按键的字节序排序.
- `env`, 这是一个`Env`类的实例, `Env`类是对操作系统的抽象, 会在后续介绍.
- `write_buffer_size`, `size_t`类型变量, 定义了写操作在刷盘前在内存中的缓冲区大小, 其作用是在执行将记录写入排序表前进行缓冲, 因此本身只追加, 不维护键顺序. 有点类似MySQL(InnoDB)的Change Buffer或WiredTiger的Write Ahead行为.
- `block_cache`, 指向`Cache`类实例的指针, 用于在主存中缓存Block, 若为`nullptr`则使用大小为8MB的内部缓存, `Cache`类也会在后续介绍.
- `block_restart_interval`, `int`类型变量, 定义了Block内部每隔多少个键值安插一个重启点(Restart Point). leveldb通过重启点机制加速对键的查找. 同样的, 后续展开.
- `compression`, `CompressionType`枚举, 即前文所描述的压缩算法.
- `filter_policy`, 指向`FilterPolicy`类实例的指针, 若不为`nullptr`, 则在读操作前通过该指针指向的实例, 比如布隆过滤器实现, 来对查询进行预过滤, 从而降低读负载. 这个优化很多数据库都有.

#### ReadOptions

`DB`类实例上读操作函数, 如`Get`, 接受的参数配置. 比较简单, 目前就3个属性:

- `verify_checksum`, 顾名思义, 读取是否要验证检查和, 如果验证不通过说明数据已损坏.
- `fill_cache`, 也比较好理解, 即此次读操作是否刷缓存, 比如进行批量遍历时, 我们可能不希望这些一次性数据被写入缓存导致缓存中某些热点数据被踢出从而降低后续命中率, 就可以把这个参数置为`false`.
- `snapshot`, 指向`Snapshot`类实例的指针, 若不为`nullptr`, 则本次读取将基于指针指向的快照, 否则, 将建立并使用读取开始时状态的快照.

#### WriteOptions

`DB`实例上写操作函数, 如`Put`, 接受的参数配置, 也很简单, 目前就1个属性:

- `sync`, `bool`类型变量, 若为`true`, 则会等待数据从操作系统Buffer Cache刷盘完成后再返回. 如果有数据库开发基本知识的话应该知道, 操作系统写操作返回和数据真正落盘并不完全相等, 因为操作系统在中间会有一层缓冲, 对文件的写操作会先写到Buffer Cache, 再刷到磁盘. 正常情况下, 即使进程Crash掉了, 但只要写操作从操作系统返回, 写出的内容仍然会被操作系统从Buffer Cache刷到磁盘, 但如果操作系统在刷盘前Crash掉了, 数据就会丢失. 为了避免这种情况, 可以通过相关接口要求操作系统将Buffer Cache中的内容同步至磁盘文件后返回, 在leveldb中该行为被封装为`WriteableFile`类的`Sync`方法, 在POSIX下实际为一次`fsync`调用. 显然, 如果每次写入都置为true`, 则Buffer Cache就失去了意义, 进而会降低写入速度.

### comparator.h

这个头文件只包含对键顺序比较的封装.

#### Comparator类

该类的职责即定义如何比较两个键, 由于在leveldb中键被封装为`Slice`类的实例, 因此就是定义如何比较两个`Slice`类的实例. 同时, 由于实现类的实例会被leveldb并发访问, 因此要求其方法必须为线程安全的.

比较的具体规则定义在`Compare`函数中, 该函数为纯虚函数, 由子类给出定义. 每个`Comparator`类的子类还需要实现`Name`方法, 来相互区分. 这是因为leveldb的键值是内部有序的, 而顺序的比较方式必须在数据库被创建时就指定, 且指定后不能随意更换. 这其实很好理解, 既然磁盘上的文件内部按某种比较规则维护了顺序, 那下次打开数据库时如果可以随意更换比较规则, 必然导致现有磁盘上的键值顺序变得无法信任. 因此数据在写出时会标明`Comparator`的名字, 下次更换比较器打开数据库会抛出错误. 当然, 比较器的实现者可以通过在键上标记版本, 在不改变名字的前提下更新兼容的比较规则.

另外两个不是很好根据名字理解的方法, `FindShortestSeparator`和`FindShortSuccessor`主要用于降低内部数据结构, 如索引Block的磁盘占用, 这里先不展开.

leveldb内存储的键值默认按键的字节序排序, 因此提供了内建的实现类`BytewiseComparator`. 后续介绍.