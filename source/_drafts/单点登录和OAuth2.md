---
title: 单点登录和OAuth2
date: 2019-06-09 22:04:00
tags:
---
用户鉴权自互联网诞生以来就一直是 Web 应用不可避免的一个话题, 尤其随着应用规模的不断扩大, 多租户 SaaS 应用和微服务架构愈发流行, 这种小而精的开发方式从架构, 项目维护性, 用户体验等很多方面相较以往的不断追求大而全进而导致项目愈发臃肿的结果相比体现出了明显的优势, 但也随之带来了另一些问题, 比如服务发现(于是流行了 Spring Cloud 全家桶), 比如远程调用(于是国内行了 Dubbo 和 GRPC), 比如运维难度(于是流行了 Docker 和 Kubernetes)等等, 不过今天主要讨论的是一个看似简单但有十分重要的问题, 那就这种体系下的验证和鉴权问题, 也就是单点登录(SSO, Single Sign On)问题.

即使你没有刻意研究过单点登录, 但实际上你肯定已经是他的用户之一了, 比如你登录了 Google 账号, 你会发现自己同时也登录了 Gmail 和 Youtue, 尽管他们被部署在不同域名下. 实际上单点登录作为认证和鉴权的入口, 其安全性, 易用性和可扩展性十分重要, 对接公有云上的 SaaS 应用同时意味着客户对于平台的充分信任, 因此服务提供商有责任保证这些数据不会被恶意窃取.

# 传统认证手段

用户名和密码: 在此种情形中, 用户提供一个可辨别的, 全局唯一的代号和对应的密码来进行认证, 这一代号可以是用户定义的不可重复的用户名, 也可以是用户的电子邮件地址或手机号码. 由于用户直接提供了极具敏感性的密码信息, 因此数据在传输和存储过程中都应有哈希和盐化处理, 否则当数据泄露时平台的所有用户都将面临风险, 现代浏览器提供了跨平台的强密码生成和记忆钥匙环以提升此种交互下的用户体验与安全性.

社交账号: 这是当下非常流行的方式, 用户利用其在其他平台的现有账号进行登录, 这对于那些不愿意注册过多账号的用户更具吸引力, 服务提供商因此降低了成本和安全风险, 同时还能根据社交平台提供的用户基本信息来快速构建用户画像, 以实现后续的精准推荐等服务. 但这种方式的弊端在于过多的依赖了其他平台, 导致如果相应接口变更甚至被关闭时, 用户认证将受到强烈影响.

无密码登录: 这种方式下用户仅需提供电子邮件地址或手机号码, 而无需提供密码. 他会在注册时受到来自服务提供商的魔法链接或验证码, 用户可以凭此进行认证. 从用户的角度而言并未提供任何自身的敏感信息, 认证过程中顾虑更少, 从平台的校对来说在数据泄露时风险也更低.

多因素认证: 多因素认证或更为常见的翻译"两步验证"虽然不是一种单独的认证方式, 但由于他极大的提升了认证过程的安全性而在此处值得一提. 多因素认证通常会在传统的认证过程结束前, 要求用户提供额外的信息以完成最终的认证, 比如回答验证问题或者提供各类"安全令牌"上的 PassCode. 这种安全令牌通常基于用户标识, 时间和特定加密算法生成 PassCode.

其他神奇的认证方式如光学/超声波指纹识别, 2D 人脸图像识别, 声音识别, 三星的虹膜识别, 苹果的 3D 结构光识别等此处就不再展开.

# 单点登录
在 Web 领域, 单点登录的直观意义在于, 从用户的角度, 他在统一的认证服务器所在域名下, 通过前文所述的方式进行身份认证, 并可以在使用其他服务时自动登录, 而无需反复进行反复操作, 从实现的角度, 各个服务解耦用户认证流程, 依赖统一的认证接口, 各应用的责任和风险因此降低. 由于众所周知的浏览器同源安全策略, 不同域名下的应用无法共享 Cookie, 进而认证服务器的用户已登录信息无法通过此种方式共享至不同域名下的其他 App. 现代单点登录实现方案通常依赖于在网页重定向时追加参数, 如图所示:

{% img "" typical-sso-v2.png %}

## 名词解释
在展开讨论前我们先来看一下认证过程中的常用名词及其解释(大概列一下, 没必要现在就都看懂, 可以跳过):

Access Management: 对用户的认证/鉴权流程进行管理.
Authentication(认证): 判断用户是否是其所声明的人.
Authorization(鉴权): 判断用户能够操作的资源.
Back-end Server: 不直接面向用户的后端用户信息处理服务器.
Claim: 一个可以被信任的关于用户角色或权限的声明.
Client: 一个从服务器获取信息以供本地使用的应用.
Credentials: 用户名, 电子邮件地址, 手机号, 密码等任何用以换取实际认证令牌的数据.
Delegation: 通过调用外部 API 完成认证过程以避免存储用户敏感数据的行为.
Domain: 认证所涉及的域, 如果一个终端在域中的认证服务器上认证了, 则可以访问域上所有的服务.
Factor: 泛指一个可以确认身份的向量, 比如密码, PIN, Token, 指纹等.
Federated Identity Management: 一个共享协议的, 允许用户对认证/鉴权过程进行管理的系统.
Federation Provider: 提供单点登录认证, 用户管理的提供者.
Forest: 在同一 Federation Provider 下的一组 Domain.
Identification: 认证的过程.
Identity Provider (IdP): 一个允许用户向客户端授权的认证服务端.
Kerberos: 一个基于加密 Ticket 的认证协议.
Multifactor Authentication: 如前文所述, 为传统认证流程后追加的多因素认证.
Multitenancy: 多租户应用, 如一个 SaaS 产品.
OAuth: 一个公开的, 使用最为广泛的认证/鉴权标准, 用户告知认证服务器是否同意认证, 如何鉴权, 认证服务器依据用户请求向客户端签发 Token.
OpenID: 一个公开的认证标准, 客户端在不采集用户任何额外信息的前提下通过第三方完成用户认证.
Passwordless:  如前文所述, 一种通过魔法链接或验证码等形式的无需密码的认证方式.
Role: 对用户权限组的一种抽象.
Role-Based Access Control (RBAC): 基于 Role 对用户进行权限控制.
Security Assertion Markup Language (SAML): 一个企业级的认证/鉴权标准.
Single Sign On: 即本文讨论的核心 - 单点登录.
Social Identity Provider (Social IdP): 社会化的 IdP, 如 Google, Twitter.
Software as a Service (SaaS): 将软件视为服务而非一次性买断的产品.
Web Identity: 基于 Http 协议的认证过程.

## 常见解决方案
既然已经明白了单点登录产生的背景其相关的基本概念, 接下来我们了解一下实践中单点登录的常见解决方案.

### SAML
SAML 的本质是标记(Marked Language), 是一种特化的 XML, 这一解决方案于 2001 年被提出并在接下来一段时间流行起来, 但由于 POST 请求难以拉起移动端 App 并与之交互而在移动端优先的今天逐渐被替代.

在 SAML 的解决方案下, 由用户已登录的服务作为 IdP, 当用户希望在远程服务 SP 上认证时, IdP 通过 SAML 这种格式将用户的信息共享至 SP, 并通过 X.509 标准保证数据不被篡改, 展开这一流程如下:

1. 用户在已认证的 Domain 访问 SP.
2. SP 通过用户名, IP, 原始域名等基础信息确认用户处于 Domain 中, 并将用户重定向至 IdP.
3. IdP 确认用户的认证状态, 若未认证则验证用户并与之建立活跃的认证 Session.
4. IdP 为已认证用户构建基于 SAML 的基础信息表单, 此表单通过 X.509 标准保证其不会被篡改, 并将 POST 目标指定为 SP.
5. 表单于 User-Agent 被提交, SP 确认表单中的信息后与用户建立认证关系.


### WS-Federation
[WS-Fed](https://docs.microsoft.com/zh-cn/dotnet/framework/security/wsfederation-authentication-module-overview) 是由包括微软, IBM 在内的一批公司开发的单点登录方案, 主要用于企业服务. 尽管由微软主推, 但从结果来讲大多数公司选择了 SAML.

### OpenID Connect/OAuth
OpenID Connect 实际上是基于 [OAuth](https://oauth.net/2/) 和 JWT 的一种关注点在于认证而非授权的单点登录方案, 因此以下展开关于 OAuth 的介绍. OAuth 是一个开放的网络标准, 目前的版本 2.0 也已得到了全世界广泛的使用, 其在对于不同场景和不同安全程度给出了多种解决方案, 这里给出其中典型的一种 - 授权码(Authorization Code)模式:

{% img "" oauth2.png %}

做个比方, 我想通过企业微信登录简道云, 则图中的 User 为 User-Agent, 即我的浏览器, Client 为从企业微信获取授权信息供本地使用的应用, 即简道云, OAuth Provider 或称为 IdP 是提供认证服务的服务提供商, 即企业微信. 则 OAuth 的基本步骤如上图所示. 此过程展开来说(内容来自参考链接, 稍作整理):

1. 用户访问客户端(简道云), 后者将前者导向认证服务器(企业微信).
2. 用户选择是否给予客户端(简道云)授权.
3. 假设用户给予授权，认证服务器(企业微信)将用户导向(浏览器重定向到)客户端(简道云)事先指定的"重定向URI"(redirection URI), 同时附上一个授权码.
4. 客户端(简道云)收到授权码, 附上早先的"重定向URI", 向认证服务器(企业微信)申请令牌. 这一步是在客户端(简道云)的后台的服务器上完成的, 对用户不可见.
5. 认证服务器(企业微信)核对了授权码和重定向URI, 确认无误后, 向客户端(简道云)发送访问令牌(Access Token)和更新令牌(Refresh Token).

其中, 实际上向 IdP, 也就是上文中的企业微信请求了三次, 第一次获得了授权码, 此过程是在浏览器端完成的, 用户可见, 第二次用授权码向 IdP 换取令牌, 是在 SP, 也就是上文中的简道云后端服务器上完成的, 用户不可见. 此时 SP 已经识别了用户的身份的权限信息, 第三次或以后的更多次都是由 SP 向 IdP 换取权限范围内的资源.

但上述过程实际上存在一个 CSRF 漏洞, 比如(过程虚构, 内容来自参考链接, 稍作整理):

1. 攻击者李四登录了简道云, 并且选择绑定自己的企业微信账号.
2. 简道云将李四重定向至企业微信, 由于李四登陆过企业微信, 因此企业微信询问李四是否授权.
3. 李四点击同意授权后, 截获了来自企业微信的授权码响应.
4. 李四精心构造了一个仿制的简道云页面, 并且该页面会重定向至简道云并触发该网站向企业微信申请令牌, 而请求中的授权码正是李四的授权码.
5. 李四将该网站放到互联网上, 并诱导目标用户张三访问.
6. 张三此前登录过企业微信网站, 但并未与简道云绑定. 张三访问了李四精心准备的网站, 并触发了简道云通过请求中的授权码向企业微信申请令牌的动作.
7. 简道云成功获取了令牌, 尽管这个令牌实际属于李四, 但张三和简道云都不知道.
8. 于是张三的简道云账户和李四的企业微信账户关联起来, 李四可以通过自己的企业微信以张三的身份访问简道云.

这一切发生的很快, 从用户张三的角度来讲, 他确实在企业微信的官方网站上点击了授权, 并且申请权限的是由企业微信认证过的简道云, 但最终自己的账号却和李四绑定在一起, 并未察觉异样的张三账号中的数据因此泄露. 李四在窃取资料后进行解绑, 于是用户在发现数据泄露后将这一切怪到 SP 也就是简道云的头上.

{% img "" csrf.png %}

因此一个在 OAuth 文档中写为可选, 实际上被很多开发者忽略或误用的参数起到了关键作用, 那就是 state. 简道云应当在第一次将李四重定向到企业微信时生成一个随机的, 不可预测的, 短时效并且与李四当前会话绑定的 state. 如果李四为自己的账号绑定, 由于企业微信实现了 OAuth 标准继而会原封不动的返回这一 state 参数, 从而在简道云正确认证. 但如果李四使用该 code 和 state 尝试绑定张三的账号, 则由于在张三的会话中这一参数并不匹配, 简道云不会通过这次请求, 进而修复了该安全漏洞.

### LDAP
轻量级目录访问协议的作用正如他的名字, 本身是对简单信息的一种树状存储方式, 由于其易于接入和在各类产品中广泛支持的特性而被很多企业作为员工单点登录的解决方案, 但这种解决方案更倾向于面向企业内部使用, 而不适合集成在业务复杂的商业应用.

### Microsoft Active Directory
微软在历史上诞生了很多联合身份认证解决方案, [MSAD](https://azure.microsoft.com/zh-cn/services/active-directory/) (ADFS, Azure AD) 是在大刀队的践踏下仍然存活至今的一个, 也是微软生态中目前较为流行的单点登录解决方案.

# 参考资料
1. [Auth0](https://auth0.com/)
2. [OneLogin](https://developers.onelogin.com)
3. [OAuth vs. SAML vs. OpenID Connect](https://www.gluu.org/blog/oauth-vs-saml-vs-openid-connect/)
4. [理解 OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)
5. [移花接木：针对OAuth2的CSRF攻击](https://www.jianshu.com/p/c7c8f51713b6)
